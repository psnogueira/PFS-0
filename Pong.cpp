/***************************************
 * Pong game
 * Made with OpenGL
 *--------------------------------------
 * Created by psnogueira on 17/10/2023
 ***************************************/

#if defined(_WIN32)
#include "Window.hpp"
#else
#error Unsupported platform
#endif

#include <Windows.h>
#include <set>
#include <utility>
#include <string>
#include <vector>
#include <iostream>

#include "Pong.hpp"
#include "Log.hpp"
#include "GL.hpp"

 ///
 /// Important variables
 ///

 // WinSize
 // static constexpr Vector2i skWinSize = {1280, 720};

static bool sInitialized = false;
static bool sRunning = false;

// Window & Context
platform_window_t* sWindow;
static HWND sWindow2;
static HGLRC sContext;

// Game state
static bool sPlaying = false;
static unsigned s_PlayerScores[] = { 0u, 0u };

// Ball

// Paddles

#define LOG_GL_STRING(name, stringName) \
    SM_CUSTOM(TEXT_COLOR_BRIGHT_YELLOW, name, reinterpret_cast<const char*>(GL::GetString(stringName)))

/// ! @brief A Class with the Init() and Cleanup() functions of any item.
///
class Lifetime
{
public:

	///! @brief Generic initialization function that returns false on failure.
	///
	/// @return Whether the Initialization was successful.
	using PFNInit = bool (*)();

	///! @brief Generic cleanup function.
	///
	using PFNCleanup = void (*)();

private:

	PFNInit mInit;
	PFNCleanup mCleanup;

public:

	/// <summary> Lifetime constructor.
	/// Both Init() and Cleanup() functions are necessary.
	/// </summary>
	/// <param name="initFunction"></param>
	/// <param name="cleanupFunction"></param>
	constexpr Lifetime(PFNInit init, PFNCleanup cleanup) noexcept
		: mInit(init), mCleanup(cleanup)
	{

	}

public:

	///! @brief Lifetime item's initialization function that returns false on failure.
	///
	/// @return Whether the Initialization was successful.
	constexpr bool Init() const noexcept
	{
		return mInit();
	}

	///! @brief Lifetime item's cleanup function.
	///
	constexpr void Cleanup() const noexcept
	{
		mCleanup();
	}

};

///
/// Initialize the game's systems.
/// 
static bool InitGameSystems() noexcept;

///
/// Cleans up the game's systems.
/// 
static void CleanupGameSystems() noexcept;

///
/// Initialize the game's state and resources.
/// 
static bool InitState() noexcept;

///
/// Cleans up the game's state and resources.
/// 
static void CleanupState() noexcept;


///
/// All the game Lifetimes.
/// 
/// It is an array containing instances of the class Lifetime.
/// Every instance is generated by giving an Init and Cleanup function.
/// 
static constexpr Lifetime kGameLifetimes[] =
{
	{InitGameSystems, CleanupGameSystems},
	{InitState, CleanupState}
};

/// 
/// Simple wrapper for the array reference syntax.
/// 
template<typename T, std::size_t Size>
using ConstArrayReference = const T(&)[Size];

template<std::size_t NumItems>
bool TryInitItems(ConstArrayReference<Lifetime, NumItems> lifetimes) noexcept;

/// 
/// Initialization function
/// 
bool pong::Init() noexcept
{
	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "Initialization()", "");

	// If the game is already initialized, this function returns false.
	if (sInitialized)
	{
		SM_WARN("Game has already initilized!");
		return false;
	}
		
	sInitialized = TryInitItems(kGameLifetimes);

	if (sInitialized)
		SM_TRACE("Initialization was SUCCESSFUL!");
	
	return sInitialized;
}

///
/// ------------------------- Init -------------------------
/// 
/// {InitGameSystems, CleanupGameSystems},
/// {InitState, CleanupState}
///
/// -------------------- (InitGameSystems) --------------------
/// 
/// {WindowInit, WindowCleanup}, Registra Janela
/// {GraphicsInit, GraphicsCleanup },
/// {glInit, glCleanup },
/// {TimeInit, TimeCleanup }
///
/// -------------------- (InitState) --------------------
/// 
/// {InitGameWindow, CleanupGameWindow},
/// {InitContext, CleanupContext},
/// {InitGraphicsResources, CleanupGraphicsResources }
/// 
/// ------------ (InitGraphicsResources) ------------
/// 
/// {InitPaddleProgram, CleanupPaddleProgram},
/// {InitBallProgram, CleanupBallProgram},
/// {InitQuad, CleanupQuad },
/// {InitTextureQuad, CleanupTextureQuad }
/// 
/// 

template<std::size_t NumItems>
static void CleanupItemsStartingAt(ConstArrayReference<Lifetime, NumItems> lifetimes, unsigned index) noexcept;

///
/// Trys to initialize all given items
/// 
template<std::size_t NumItems> 
bool TryInitItems(ConstArrayReference<Lifetime, NumItems> lifetimes) noexcept
{
	bool succeded = true;

	for (unsigned i = 0; succeded && i < NumItems; i++)
	{
		succeded = lifetimes[i].Init();

		if (!succeded)
		{
			CleanupItemsStartingAt(lifetimes, i);
		}
	}

	return succeded;
}

template<std::size_t NumItems>
void CleanupItemsStartingAt(ConstArrayReference<Lifetime, NumItems> lifetimes, unsigned index) noexcept
{
	for (int i = static_cast<int>(index) - 1; i >= 0; i--)
	{
		lifetimes[i].Cleanup();
	}
}

//
static bool WindowInit() noexcept;

//
static void WindowCleanup() noexcept;

//
static bool GraphicsInit() noexcept;

//
static void GraphicsCleanup() noexcept;

//
static bool glInit() noexcept;

//
static void glCleanup() noexcept;

//
static bool TimeInit() noexcept;

//
static void TimeCleanup() noexcept;

///
/// All the system Lifetimes.
/// 
/// It is an array containing instances of the class Lifetime.
/// Every instance is generated by giving an Init and Cleanup function.
/// 
static constexpr Lifetime kSystemLifetimes[] =
{
	{WindowInit, WindowCleanup},
	{GraphicsInit, GraphicsCleanup },
	{glInit, glCleanup},
	{TimeInit, TimeCleanup}

	// Need to add:
	//
	// Log::Init, Log::Cleanup
	// Window::Init, Window::Cleanup
	// Graphics::Init, Graphics::Cleanup
	// gl::Init, gl::Cleanup
	// Time::Init, Time::Cleanup

};

bool InitGameSystems() noexcept
{
	return TryInitItems(kSystemLifetimes);
}


///
/// Calls the cleanup function of all the provided item lifetimes.
///
template<std::size_t NumItems>
static void CleanupItems(ConstArrayReference<Lifetime, NumItems> itemLifetimes) noexcept;

void CleanupGameSystems() noexcept
{
	CleanupItems(kSystemLifetimes);
}

template<std::size_t NumItems>
void CleanupItems(ConstArrayReference<Lifetime, NumItems> itemLifetimes) noexcept
{
	CleanupItemsStartingAt(itemLifetimes, NumItems);
}

//
static bool InitGameWindow() noexcept;

//
static void CleanupGameWindow() noexcept;

//
static bool InitContext() noexcept;

//
static void CleanupContext() noexcept;

//
static bool InitGraphicsResources() noexcept;

//
static void CleanupGraphicsResources() noexcept;

///
/// All the game state Lifetimes.
/// 
/// It is an array containing instances of the class Lifetime.
/// Every instance is generated by giving an Init and Cleanup function.
/// 
static constexpr Lifetime kStateLifetimes[] =
{
	{InitGameWindow, CleanupGameWindow},
	{InitContext, CleanupContext},
	{InitGraphicsResources, CleanupGraphicsResources}
};

bool InitState() noexcept
{
	return TryInitItems(kStateLifetimes);
}

void CleanupState() noexcept
{
	CleanupItems(kStateLifetimes);
}

/// 
/// <param name="key -> The pressed key's virtual key code."></param>
/// <param name="pressed - > Whether the key was presssed."></param>
//static void OnKeyEvent(int key, bool pressed) noexcept;

bool InitGameWindow() noexcept
{
	SM_TRACE("InitGameWindow()");

	//Window::SetKeyCallback(OnKeyEvent);
	
	const unsigned int window_width = 1024;
	const unsigned int window_height = 512;

	sWindow = Window::createWindow(window_width, window_height);

	if (!sWindow) {
		printf("Failed to create window.\n");
		return false;
	}

	return true;
}

/// 
/// All the game state Lifetimes Definitions
/// 
/// {InitGameWindow, CleanupGameWindow},
/// {InitContext, CleanupContext},
/// {InitGraphicsResources, CleanupGraphicsResources }
///  

//InitGameWindow()

void CleanupGameWindow() noexcept
{
	//Window::DestroyWindow(sWindow);
}

bool InitContext() noexcept
{
	SM_TRACE("InitContext()");

	sContext = GL::MakeContext(sWindow);
	const bool contextIsValid = sContext;

	if (contextIsValid)
	{
		GL::MakeContextCurrent(sWindow, sContext);
	}

	return contextIsValid;
}
///MakeContext(sWindow)
///MakeContextCurrent(sContext)
///DeleteContext(sContext)

void CleanupContext() noexcept
{
	GL::DeleteContext(sContext);
}

bool InitGraphicsResources() noexcept
{
	// Initialize Shaders with OpenGL
	if (!GL::InitializeShaders()) {
		printf("Scene initialization failed.\n");
		return false;
	}

	return true;
}

void CleanupGraphicsResources() noexcept
{

}


/// 
/// All the system Lifetimes Definitions
/// 
/// Log::Init, Log::Cleanup
/// Window::Init, Window::Cleanup
/// Graphics::Init, Graphics::Cleanup
/// gl::Init, gl::Cleanup
/// Time::Init, Time::Cleanup
/// 

/// ! @brief Initializes the dummy Window.
/// 
/// Creates a dummy window and a dummy context for OpenGL Initialization.
///  
/// @return Whether the dummy window was successfully initialized.
/// 
bool WindowInit() noexcept
{
	SM_TRACE("WindowInit()");
	const unsigned int window_width = 512;
	const unsigned int window_height = 512;

	sWindow = Window::createWindow(window_width, window_height);
	
	if (!sWindow) {
		printf("Failed to create window.\n");
		return false;
	}
	
	return true;
}

void WindowCleanup() noexcept
{
	Window::DestroyWindow(sWindow);
}

/*
	* Init() and Cleanup() of Graphics.cpp
	
	// Init
	//

	static HMODULE isOpenGLLibary = nullptr;

	isOpenGLLibary = LoadLibraryA("OpenGL32.dll");
	SM_ASSERT(isOpenGLLibary,"Failed to load OpenGL");

	// Cleanup
	//

	FreeLibrary(isOpenGLLibary);
	isOpenGLLibary = nullptr;

	*/

bool GraphicsInit() noexcept
{
	SM_TRACE("GraphicsInit()");

	return true;
}

void GraphicsCleanup() noexcept
{

}

bool glInit() noexcept
{
	SM_TRACE("glInit()");

	// Initialize OpenGL function pointers 
	if (!GL::LoadOpenGLFunction())
	{
		SM_ASSERT(false, "Failed to load OpenGL Functions");
		return false;
	}

	Window::DestroyWindow(sWindow);
	
	return true;
}
void glCleanup() noexcept
{

}

bool TimeInit() noexcept
{
	SM_TRACE("TimeInit()");

	return true;
}

void TimeCleanup() noexcept
{

}

static void OnBeginRun() noexcept;
static void OnFinishRun() noexcept;
static float GetDeltaTime() noexcept;
static void OnUpdate(float deltaTime) noexcept;
static void OnRender() noexcept;

void pong::Run() noexcept
{
	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "Run()", "");

	sRunning = true;
	OnBeginRun();

	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "Main Loop", "");
	while (sRunning)
	{
		const float deltaTime = GetDeltaTime();

		bool quit = Window::HandleEvents(sWindow);
		if (quit) {
			break;
		}

		OnUpdate(deltaTime);
		OnRender();

		//Window::swap(window);
		GL::SwapBuffers(sWindow);
	}

	OnFinishRun();
}

void LogContextSpecifications() noexcept;

static void OnBeginRun() noexcept
{
	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "OnBeginRun()", "");
	Window::ShowWindow(sWindow);
	// Set Window Resizible (false)

	// Log Context Specifications
	LogContextSpecifications();
	
	// Reset game state
	// Position Paddles

	// srand(currentTime)?
}

void LogContextSpecifications() noexcept
{
	LOG_GL_STRING("GL_VENDOR: ", GL_VENDOR);
	LOG_GL_STRING("GL_VERSION: ", GL_VERSION);
	LOG_GL_STRING("GL_RENDERER: ", GL_RENDERER);
}

void OnFinishRun() noexcept
{
	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "OnFinishRun()", "");

}

void pong::Cleanup() noexcept
{
	//std::cout << "Cleanup()" << std::endl;
	SM_CUSTOM(TEXT_COLOR_BRIGHT_CYAN, "Cleanup()", "");

	Window::DestroyWindow(sWindow);

}

/*
static void CleanupTextureQuad() noexcept;

static constexpr Lifetime kGraphicsResourcesLifetimes[] =
{
	{InitPaddleProgram, CleanupPaddleProgram},
	{InitBallProgram, CleanupBallProgram},
	{InitQuad, CleanupQuad},
	{InitTextureQuad, CleanupTextureQuad}
};


bool InitGraphicsResources() noexcept
{
	return TryInitItems(kGraphicsResourcesLifetimes);
}

void CleanupGraphicsResources() noexcept
{

}
*/

float GetDeltaTime() noexcept
{	
	//static float sLastTime = 0.0f;

	//const float kNow = Time::Get();
	//const float kTimeDelta = kNow - sLastTime;
	//sLastTime = kNow;

	//return kTimeDelta;

	return 1.0f;
}

void OnUpdate(float deltaTime) noexcept
{
	// Delta time (float deltaTime)
	// sRunning = Window::PollEvents();

	// Update Ball

	// Update Paddles

	// Check collision
	
	// const bool collided = collision();

	// if(collided){CheckBallSideCollision()};
}

void OnRender() noexcept
{
	GL::Clear(GL_COLOR_BUFFER_BIT);
	GL::DrawArrays(GL_TRIANGLES, 0, 3);
}

// UpdateScores(Side lostSide)
